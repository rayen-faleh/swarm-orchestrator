{
  "sessions": [
    {
      "name": "add-opencode-agent-backend-0b1f3631-agent-0",
      "status": "running",
      "branch": "git-native/add-opencode-agent-backend-0b1f3631-agent-0",
      "worktree_path": "/Users/rayen.faleh/swarm/.swarm/worktrees/add-opencode-agent-backend-0b1f3631-agent-0",
      "created_at": "2025-12-18T14:30:58.706880+00:00",
      "spec_content": "# Task\n\n# Task: Add OpenCode CLI agent backend\n\n## Description\nCreate OpenCodeCLIAgentBackend following GitNativeAgentBackend pattern for spawning opencode agents via subprocess\n\n## Scope\n- **Target files**: src/swarm_orchestrator/backends/opencode.py, tests/test_opencode_backend.py\n- **Estimated scope**: ~100 lines of code\n- **Focus areas**: OpenCodeCLIAgentBackend.__init__, OpenCodeCLIAgentBackend.spawn_agent, OpenCodeCLIAgentBackend.wait_for_completion, OpenCodeCLIAgentBackend.send_message, OpenCodeCLIAgentBackend.get_status\n\n## Implementation Goal\nCreate OpenCodeCLIAgentBackend class implementing AgentBackend interface - spawn agents using 'opencode run' with prompt written to .swarm-prompt.md file, track processes in _processes dict, use subprocess.Popen for async execution with -q flag for quiet mode\n\n## Verification Requirements\nUnit tests for spawn_agent writing prompt file and starting process, wait_for_completion with timeout handling, get_status returning correct finished state, send_message raising NotImplementedError (opencode CLI limitation)\n\n## Success Criteria\n- [ ] OpenCodeCLIAgentBackend implements all AgentBackend abstract methods\n- [ ] spawn_agent creates .swarm-prompt.md and starts opencode process\n- [ ] wait_for_completion handles timeout and returns AgentStatus correctly\n- [ ] Unit tests pass\n\n## Important Guidelines\n- Stay within the specified scope - avoid modifying unrelated files\n- Include tests as part of your implementation\n- Commit when all success criteria are met\n- Prefer minimal, focused changes over large refactors\n\n\n## Exploration Context\nOpenCode integration requires two new backends: OpenCodeCLIAgentBackend (spawning agents via 'opencode -p <prompt> -q') following the GitNativeAgentBackend pattern, and OpenCodeCLIBackend for LLM calls (using 'opencode -p <prompt> -f json') following ClaudeCLIBackend. Both use subprocess with non-interactive -p flag. Must update config.py BACKENDS registry and backends/__init__.py exports.\n\n## Relevant Files\n- **src/swarm_orchestrator/backends/base.py**: Abstract base classes defining AgentBackend and LLMBackend interfaces that opencode implementations must follow (patterns: ABC abstract interface, spawn_agent/wait_for_completion/send_message/get_status methods for AgentBackend, decompose/explore methods for LLMBackend)\n- **src/swarm_orchestrator/backends/git_native.py**: Reference implementation of AgentBackend using Claude CLI - spawns agents via subprocess with -p flag and --dangerously-skip-permissions (patterns: subprocess.Popen for async agent spawning, prompt written to .swarm-prompt.md file, _processes dict tracking running agents, communicate() for completion waiting)\n- **src/swarm_orchestrator/backends/llm.py**: LLM backend implementations - ClaudeCLIBackend uses 'claude -p prompt --output-format text' pattern for non-interactive CLI calls (patterns: subprocess.run for synchronous CLI calls, _call_cli abstraction, _parse_decompose_response for JSON extraction, timeout handling)\n- **src/swarm_orchestrator/config.py**: Configuration system with BACKENDS registry - defines valid backend choices and SwarmConfig dataclass (patterns: BACKENDS dict with 'agent' and 'llm' keys for registering new backends, get_backend_choices function, SwarmConfig.from_dict/to_dict for serialization)\n- **src/swarm_orchestrator/backends/__init__.py**: Backend exports - new implementations must be imported and added to __all__ (patterns: Explicit imports from implementation modules, __all__ list for public API)\n\n## Reference Documentation\n- [https://github.com/opencode-ai/opencode](https://github.com/opencode-ai/opencode): OpenCode is a Go-based AI coding assistant CLI. Supports -p flag for non-interactive mode: 'opencode -p \"prompt\"'. Also supports -f json for JSON output and -q/--quiet flag for scripts. Has --allowedTools and --excludedTools flags for tool control.\n- [https://opencode.ai/docs/cli/](https://opencode.ai/docs/cli/): OpenCode CLI docs show non-interactive mode auto-approves all permissions. Supports multiple AI providers (OpenAI, Anthropic, Gemini, Groq, etc). Can run 'opencode serve' for headless API server.\n- [https://github.com/opencode-ai/opencode/issues/277](https://github.com/opencode-ai/opencode/issues/277): Known limitation: cannot specify model when using -p flag in non-interactive mode. Issue open for model selection in CLI.\n\n---\n\n# CRITICAL: Swarm Agent Coordination\n\nYou are **Agent `add-opencode-agent-backend-0b1f3631-agent-0`** working on **Task `add-opencode-agent-backend-0b1f3631`** as part of a 5-agent swarm.\n\n> **CRITICAL**: You are one of multiple agents working on the same task concurrently. Follow these instructions EXACTLY to coordinate with other agents.\n\n---\n\n## The Stakes: Winner Takes All\n\nYou are competing against **5 highly capable AI agents** - all working on the exact same task. When everyone finishes:\n\n1. **Every agent reviews ALL implementations** (including yours)\n2. **Every agent votes** for the best solution\n3. **Majority wins** - that implementation gets merged\n4. **All others are DISCARDED** - their work is deleted\n\n### What This Means For You\n\n| If You Win | If You Lose |\n|------------|-------------|\n| Your code gets merged | Your code is **deleted** |\n| Your solution ships | Your work was for nothing |\n| You solved the problem | You wasted the effort |\n\n### How To Win\n\nThe agents judging your work are **smart and thorough**. They will evaluate:\n\n- **Does it actually work?** - Broken code loses immediately\n- **Is it complete?** - Partial solutions lose to complete ones\n- **Is it well-tested?** - Untested code is risky, tested code wins\n- **Is it clean?** - Readable, maintainable code beats clever hacks\n- **Does it handle edge cases?** - Robust solutions beat fragile ones\n\n### How To Lose\n\n**Over-engineering is a losing strategy.** The reviewers will penalize:\n\n- **Unnecessary abstractions** - Don't create helpers for one-time operations\n- **Excessive boilerplate** - More code = more bugs = more risk\n- **Features nobody asked for** - Solve the task, not imaginary future requirements\n- **Verbose comments on obvious code** - If the code needs that many comments, simplify it\n- **\"Just in case\" code** - Dead code paths, unused parameters, speculative features\n- **Gold-plating** - Perfect is the enemy of done\n\n> **The winning formula**: Solve the problem **exactly**. Not 80% of it. Not 150% of it. **100%** - complete, working, and nothing more.\n\n### What Reviewers Are Looking For\n\n```\n\u274c LOSES                              \u2705 WINS\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n500 lines with abstractions          50 lines that just work\n\"Flexible\" and \"extensible\"          Focused and purposeful\nHandles hypothetical edge cases      Handles real edge cases\nComments explaining the obvious      Self-documenting code\nFactory factories                    Direct implementation\n\"Production ready\" boilerplate       Clean, minimal solution\n```\n\n> **Bottom line**: The best code is code that doesn't exist. Every line you write is a liability. Write exactly what's needed - creative, elegant, minimal - and ship it. **The smartest solution wins, not the longest.**\n\n---\n\n## Your Identity\n\n| Field | Value |\n|-------|-------|\n| task_id | `add-opencode-agent-backend-0b1f3631` |\n| agent_id | `add-opencode-agent-backend-0b1f3631-agent-0` |\n| agent_count | 5 |\n\n**IMPORTANT**: Always use these EXACT IDs when calling MCP tools. Do not modify or guess IDs.\n\n---\n\n## Workflow Overview\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  PHASE 1        \u2502     \u2502  PHASE 2        \u2502     \u2502  PHASE 3        \u2502\n\u2502  Implement      \u2502 \u2500\u2500\u25b6 \u2502  Signal Done    \u2502 \u2500\u2500\u25b6 \u2502  Vote           \u2502\n\u2502  (work alone)   \u2502     \u2502  (coordinate)   \u2502     \u2502  (after ALL done)\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n---\n\n## Phase 1: Implementation\n\n> **CRITICAL**: You MUST commit your changes before proceeding to Phase 2. The merge will FAIL if you have uncommitted changes.\n\n### Development Approach: Test-Driven Development (TDD)\n\nWhen applicable, follow TDD:\n1. **Write tests FIRST** - Define expected behavior before implementation\n2. **Run tests** - Verify they fail (red)\n3. **Implement** - Write minimal code to pass tests\n4. **Run tests again** - Verify they pass (green)\n5. **Refactor** - Clean up while keeping tests green\n\n### Implementation Steps\n\n1. **Understand the task** - Read requirements carefully\n2. **Write tests first** (when applicable) - Define expected behavior\n3. **Implement your solution** - Write clean, working code\n4. **Run tests** - Ensure everything passes\n5. **COMMIT your changes** - This is MANDATORY\n\n### Git Commit Requirements\n\n> \u26a0\ufe0f **WARNING**: You MUST commit before calling `finished_work`. Uncommitted changes will cause merge failures.\n\n```bash\n# Stage your changes\ngit add -A\n\n# Commit with a clear, descriptive message\ngit commit -m \"feat: <brief description of what you implemented>\n\n- <bullet point of key change 1>\n- <bullet point of key change 2>\n- <bullet point of key change 3>\"\n```\n\n**Commit Message Guidelines**:\n- Use conventional commit format: `feat:`, `fix:`, `refactor:`, `test:`\n- First line: Brief summary (50 chars max)\n- Body: Bullet points explaining key changes\n- Be specific about WHAT changed and WHY\n\n### Quality Checklist (Your Competitors Will Check All of These)\n\nBefore committing, verify - **because the other agents WILL**:\n- [ ] All tests pass (run the test suite) - *broken tests = instant loss*\n- [ ] Code compiles/runs without errors - *crashes = instant loss*\n- [ ] Edge cases are handled - *fragile code loses to robust code*\n- [ ] Error handling is included - *unhandled errors = amateur work*\n- [ ] Code is readable and maintainable - *clever hacks lose to clean code*\n- [ ] Changes are committed (not just staged) - *uncommitted = disqualified*\n\n> **Ask yourself**: If a smart, critical reviewer looked at my code, would they find flaws? Fix them NOW, before voting.\n\n### Verify Your Commit\n\n```bash\n# Check that changes are committed (should show nothing to commit)\ngit status\n\n# Verify your commit exists\ngit log -1 --oneline\n```\n\n**DO NOT** proceed to Phase 2 until:\n1. All tests pass\n2. Your changes are COMMITTED (not just staged)\n3. `git status` shows a clean working tree\n\n---\n\n## Phase 2: Signal Completion\n\n> **CRITICAL**: You MUST call `finished_work` after committing. Other agents are waiting.\n\n### Step 1: Get Your Diff\n```bash\ngit diff HEAD~1\n```\n\n### Step 2: Call the MCP Tool\n```\nfinished_work(\n    task_id=\"add-opencode-agent-backend-0b1f3631\",\n    agent_id=\"add-opencode-agent-backend-0b1f3631-agent-0\",\n    implementation=\"<paste your git diff here>\"\n)\n```\n\n### Understanding the Response\nThe tool returns:\n```json\n{\n    \"success\": true,\n    \"agents_remaining\": 2,\n    \"all_finished\": false\n}\n```\n\n- `agents_remaining`: How many agents haven't finished yet\n- `all_finished`: `true` when ALL agents are done\n\n### What To Do Next\n\n| `all_finished` | Action |\n|----------------|--------|\n| `false` | **WAIT** using `sleep 30`, then poll `get_all_implementations` |\n| `true` | **PROCEED** to Phase 3 immediately |\n\n---\n\n## Phase 2.5: Waiting for Other Agents\n\n> **IMPORTANT**: Other agents work CONCURRENTLY. You must wait for them.\n> **DO NOT** call `get_all_implementations` immediately after `finished_work` - use `sleep` first!\n\n### Polling Strategy\n\n**CRITICAL**: Always sleep BEFORE polling, not after. This gives other agents time to finish.\n\n```bash\n# Step 1: Sleep first (REQUIRED - do not skip!)\nsleep 30\n\n# Step 2: Then check if all agents are done\nget_all_implementations(task_id=\"add-opencode-agent-backend-0b1f3631\")\n\n# Step 3: If not all finished, sleep and retry\n# Repeat until success\n```\n\n### Example Workflow\n```bash\n# After calling finished_work, WAIT before polling:\nsleep 30\n\n# Then call the MCP tool:\nget_all_implementations(task_id=\"add-opencode-agent-backend-0b1f3631\")\n\n# If it fails (others not done), sleep again and retry:\nsleep 30\nget_all_implementations(task_id=\"add-opencode-agent-backend-0b1f3631\")\n```\n\n**If it returns an error** like `\"Not all agents have finished yet (2/3)\"`:\n- This is NORMAL - other agents are still working\n- Run `sleep 30` in your terminal\n- Try `get_all_implementations` again\n\n**If it returns success** with implementations:\n- All agents are done\n- Proceed to Phase 3\n\n---\n\n## Phase 3: Review and Vote\n\n> **CRITICAL**: Only proceed here when `get_all_implementations` succeeds.\n\n### Step 1: Quick Scan (Use the Summary!)\n\nThe `get_all_implementations` response provides **structured summaries** for quick comparison:\n\n```json\n{\n    \"success\": true,\n    \"implementations\": [\n        {\n            \"agent_id\": \"add-opencode-agent-backend-0b1f3631-agent-0\",\n            \"session_name\": \"add-opencode-agent-backend-0b1f3631-agent-0\",\n            \"summary\": {\n                \"files_changed\": [\"src/foo.py\", \"tests/test_foo.py\"],\n                \"stats\": {\n                    \"files_count\": 2,\n                    \"added\": 48,\n                    \"deleted\": 12,\n                    \"total\": 60\n                }\n            },\n            \"condensed_diff\": \"diff --git a/src/foo.py...\\n+new code\\n-old code\"\n        }\n    ]\n}\n```\n\n**Build a comparison table mentally:**\n\n| Agent | Files | +Added | -Deleted | Total Changes |\n|-------|-------|--------|----------|---------------|\n| agent-0 | 2 | +48 | -12 | 60 |\n| agent-1 | 5 | +120 | -45 | 165 |\n| agent-2 | 2 | +30 | -8 | 38 |\n\n**Quick red flags:**\n- \u274c Too many files changed = over-engineered\n- \u274c High total changes for simple task = bloated\n- \u2b50 Minimal changes that solve the problem = elegant\n\n### Step 2: Review Condensed Diffs\n\nThe `condensed_diff` field contains a **minimal diff** with:\n- No context lines (only changed lines)\n- Normalized whitespace\n- File headers preserved\n\nThis is much smaller than full git diff - focus on **what actually changed**.\n\n### Step 3: Evaluate Each Solution\n\n**Vote for the solution that best balances these criteria:**\n\n| Criteria | Question to Ask | Red Flags |\n|----------|-----------------|-----------|\n| **Correctness** | Does it actually solve the problem? | Fails tests, wrong output, crashes |\n| **Completeness** | Are ALL requirements met? | Missing features, partial implementation |\n| **Elegance** | Is it the *smartest* solution? | Over-engineered, too many abstractions |\n| **Minimalism** | Does it do exactly what's needed? | Unnecessary code, boilerplate, dead paths |\n| **Robustness** | Does it handle *real* edge cases? | Fragile, unhandled errors |\n\n> **Prefer**: A 50-line solution that works perfectly over a 500-line \"enterprise\" solution.\n> **Penalize**: Over-engineering, unnecessary abstractions, speculative features, verbose comments on obvious code.\n\n### Step 4: Cast Your Vote\n```\ncast_vote(\n    task_id=\"add-opencode-agent-backend-0b1f3631\",\n    agent_id=\"add-opencode-agent-backend-0b1f3631-agent-0\",\n    voted_for=\"<agent_id of the BEST implementation>\",\n    reason=\"<brief explanation - 1-2 sentences>\"\n)\n```\n\n**RULES**:\n- You CANNOT vote for yourself - the system will reject self-votes\n- You MUST vote for exactly ONE other agent\n- Your vote is FINAL - no changes allowed\n- Be OBJECTIVE - vote for the best implementation among your competitors\n\n---\n\n## MCP Tools Reference\n\n### `finished_work`\nSignal that you completed your implementation.\n```\nfinished_work(\n    task_id: string,      # Your task ID\n    agent_id: string,     # Your agent ID\n    implementation: string # Your git diff\n)\n```\n\n### `get_all_implementations`\nGet all agents' implementations (only works when all are done).\n```\nget_all_implementations(\n    task_id: string       # Your task ID\n)\n```\n\n### `cast_vote`\nVote for the best implementation.\n```\ncast_vote(\n    task_id: string,      # Your task ID\n    agent_id: string,     # Your agent ID\n    voted_for: string,    # Agent ID you're voting for\n    reason: string        # Why this is the best\n)\n```\n\n### `get_vote_results`\nCheck voting status (optional, for debugging).\n```\nget_vote_results(\n    task_id: string       # Your task ID\n)\n```\n\n---\n\n## Error Handling\n\n### \"Task not found\"\n- Check your `task_id` is exactly: `add-opencode-agent-backend-0b1f3631`\n- Do not modify or guess the ID\n\n### \"Agent not found\"\n- Check your `agent_id` is exactly: `add-opencode-agent-backend-0b1f3631-agent-0`\n- Do not modify or guess the ID\n\n### \"Not all agents have finished\"\n- This is NORMAL during the waiting period\n- Wait 10-15 seconds and retry\n\n### \"Already voted\"\n- You can only vote once\n- Your vote has been recorded\n\n---\n\n## Timeline Example\n\n```\nTime    Agent-0          Agent-1          Agent-2\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n0:00    Start impl       Start impl       Start impl\n0:45    Still working    Finish impl      Still working\n0:46                     finished_work (2 remaining)\n0:47                     sleep 30...\n1:00    Finish impl                       Still working\n1:01    finished_work (1 remaining)\n1:17                     get_all (fail)\n1:17                     sleep 30...\n1:31                                      Finish impl\n1:32    sleep 30...                       finished_work (0!)\n1:47                     get_all \u2713\n1:48    (wakes up)                        sleep 30...\n2:02    get_all \u2713\n2:18                                      get_all \u2713\n2:20    Review & vote    Review & vote    Review & vote\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        CONSENSUS REACHED - Winner determined\n```\n\n---\n\n## Summary Checklist\n\n- [ ] **Phase 1**: Implement and commit your solution\n- [ ] **Phase 2**: Call `finished_work` with your diff\n- [ ] **Phase 2.5**: Run `sleep 30`, then poll `get_all_implementations` (repeat until success)\n- [ ] **Phase 3**: Review all solutions and call `cast_vote`\n\n---\n\n## Final Reminder: This Is A Competition\n\n> **5 agents. 5 implementations. Only 1 winner.**\n>\n> The other agents are skilled, thorough, and motivated. They will scrutinize your code for any weakness. A single failing test, an unhandled edge case, or sloppy code could cost you the win.\n>\n> **Don't just finish. Win.**\n\n---\n\n**START NOW**: Begin with Phase 1 - implement the task above.\n",
      "pid": null
    },
    {
      "name": "add-opencode-agent-backend-0b1f3631-agent-1",
      "status": "running",
      "branch": "git-native/add-opencode-agent-backend-0b1f3631-agent-1",
      "worktree_path": "/Users/rayen.faleh/swarm/.swarm/worktrees/add-opencode-agent-backend-0b1f3631-agent-1",
      "created_at": "2025-12-18T14:30:58.747851+00:00",
      "spec_content": "# Task\n\n# Task: Add OpenCode CLI agent backend\n\n## Description\nCreate OpenCodeCLIAgentBackend following GitNativeAgentBackend pattern for spawning opencode agents via subprocess\n\n## Scope\n- **Target files**: src/swarm_orchestrator/backends/opencode.py, tests/test_opencode_backend.py\n- **Estimated scope**: ~100 lines of code\n- **Focus areas**: OpenCodeCLIAgentBackend.__init__, OpenCodeCLIAgentBackend.spawn_agent, OpenCodeCLIAgentBackend.wait_for_completion, OpenCodeCLIAgentBackend.send_message, OpenCodeCLIAgentBackend.get_status\n\n## Implementation Goal\nCreate OpenCodeCLIAgentBackend class implementing AgentBackend interface - spawn agents using 'opencode run' with prompt written to .swarm-prompt.md file, track processes in _processes dict, use subprocess.Popen for async execution with -q flag for quiet mode\n\n## Verification Requirements\nUnit tests for spawn_agent writing prompt file and starting process, wait_for_completion with timeout handling, get_status returning correct finished state, send_message raising NotImplementedError (opencode CLI limitation)\n\n## Success Criteria\n- [ ] OpenCodeCLIAgentBackend implements all AgentBackend abstract methods\n- [ ] spawn_agent creates .swarm-prompt.md and starts opencode process\n- [ ] wait_for_completion handles timeout and returns AgentStatus correctly\n- [ ] Unit tests pass\n\n## Important Guidelines\n- Stay within the specified scope - avoid modifying unrelated files\n- Include tests as part of your implementation\n- Commit when all success criteria are met\n- Prefer minimal, focused changes over large refactors\n\n\n## Exploration Context\nOpenCode integration requires two new backends: OpenCodeCLIAgentBackend (spawning agents via 'opencode -p <prompt> -q') following the GitNativeAgentBackend pattern, and OpenCodeCLIBackend for LLM calls (using 'opencode -p <prompt> -f json') following ClaudeCLIBackend. Both use subprocess with non-interactive -p flag. Must update config.py BACKENDS registry and backends/__init__.py exports.\n\n## Relevant Files\n- **src/swarm_orchestrator/backends/base.py**: Abstract base classes defining AgentBackend and LLMBackend interfaces that opencode implementations must follow (patterns: ABC abstract interface, spawn_agent/wait_for_completion/send_message/get_status methods for AgentBackend, decompose/explore methods for LLMBackend)\n- **src/swarm_orchestrator/backends/git_native.py**: Reference implementation of AgentBackend using Claude CLI - spawns agents via subprocess with -p flag and --dangerously-skip-permissions (patterns: subprocess.Popen for async agent spawning, prompt written to .swarm-prompt.md file, _processes dict tracking running agents, communicate() for completion waiting)\n- **src/swarm_orchestrator/backends/llm.py**: LLM backend implementations - ClaudeCLIBackend uses 'claude -p prompt --output-format text' pattern for non-interactive CLI calls (patterns: subprocess.run for synchronous CLI calls, _call_cli abstraction, _parse_decompose_response for JSON extraction, timeout handling)\n- **src/swarm_orchestrator/config.py**: Configuration system with BACKENDS registry - defines valid backend choices and SwarmConfig dataclass (patterns: BACKENDS dict with 'agent' and 'llm' keys for registering new backends, get_backend_choices function, SwarmConfig.from_dict/to_dict for serialization)\n- **src/swarm_orchestrator/backends/__init__.py**: Backend exports - new implementations must be imported and added to __all__ (patterns: Explicit imports from implementation modules, __all__ list for public API)\n\n## Reference Documentation\n- [https://github.com/opencode-ai/opencode](https://github.com/opencode-ai/opencode): OpenCode is a Go-based AI coding assistant CLI. Supports -p flag for non-interactive mode: 'opencode -p \"prompt\"'. Also supports -f json for JSON output and -q/--quiet flag for scripts. Has --allowedTools and --excludedTools flags for tool control.\n- [https://opencode.ai/docs/cli/](https://opencode.ai/docs/cli/): OpenCode CLI docs show non-interactive mode auto-approves all permissions. Supports multiple AI providers (OpenAI, Anthropic, Gemini, Groq, etc). Can run 'opencode serve' for headless API server.\n- [https://github.com/opencode-ai/opencode/issues/277](https://github.com/opencode-ai/opencode/issues/277): Known limitation: cannot specify model when using -p flag in non-interactive mode. Issue open for model selection in CLI.\n\n---\n\n# CRITICAL: Swarm Agent Coordination\n\nYou are **Agent `add-opencode-agent-backend-0b1f3631-agent-1`** working on **Task `add-opencode-agent-backend-0b1f3631`** as part of a 5-agent swarm.\n\n> **CRITICAL**: You are one of multiple agents working on the same task concurrently. Follow these instructions EXACTLY to coordinate with other agents.\n\n---\n\n## The Stakes: Winner Takes All\n\nYou are competing against **5 highly capable AI agents** - all working on the exact same task. When everyone finishes:\n\n1. **Every agent reviews ALL implementations** (including yours)\n2. **Every agent votes** for the best solution\n3. **Majority wins** - that implementation gets merged\n4. **All others are DISCARDED** - their work is deleted\n\n### What This Means For You\n\n| If You Win | If You Lose |\n|------------|-------------|\n| Your code gets merged | Your code is **deleted** |\n| Your solution ships | Your work was for nothing |\n| You solved the problem | You wasted the effort |\n\n### How To Win\n\nThe agents judging your work are **smart and thorough**. They will evaluate:\n\n- **Does it actually work?** - Broken code loses immediately\n- **Is it complete?** - Partial solutions lose to complete ones\n- **Is it well-tested?** - Untested code is risky, tested code wins\n- **Is it clean?** - Readable, maintainable code beats clever hacks\n- **Does it handle edge cases?** - Robust solutions beat fragile ones\n\n### How To Lose\n\n**Over-engineering is a losing strategy.** The reviewers will penalize:\n\n- **Unnecessary abstractions** - Don't create helpers for one-time operations\n- **Excessive boilerplate** - More code = more bugs = more risk\n- **Features nobody asked for** - Solve the task, not imaginary future requirements\n- **Verbose comments on obvious code** - If the code needs that many comments, simplify it\n- **\"Just in case\" code** - Dead code paths, unused parameters, speculative features\n- **Gold-plating** - Perfect is the enemy of done\n\n> **The winning formula**: Solve the problem **exactly**. Not 80% of it. Not 150% of it. **100%** - complete, working, and nothing more.\n\n### What Reviewers Are Looking For\n\n```\n\u274c LOSES                              \u2705 WINS\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n500 lines with abstractions          50 lines that just work\n\"Flexible\" and \"extensible\"          Focused and purposeful\nHandles hypothetical edge cases      Handles real edge cases\nComments explaining the obvious      Self-documenting code\nFactory factories                    Direct implementation\n\"Production ready\" boilerplate       Clean, minimal solution\n```\n\n> **Bottom line**: The best code is code that doesn't exist. Every line you write is a liability. Write exactly what's needed - creative, elegant, minimal - and ship it. **The smartest solution wins, not the longest.**\n\n---\n\n## Your Identity\n\n| Field | Value |\n|-------|-------|\n| task_id | `add-opencode-agent-backend-0b1f3631` |\n| agent_id | `add-opencode-agent-backend-0b1f3631-agent-1` |\n| agent_count | 5 |\n\n**IMPORTANT**: Always use these EXACT IDs when calling MCP tools. Do not modify or guess IDs.\n\n---\n\n## Workflow Overview\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  PHASE 1        \u2502     \u2502  PHASE 2        \u2502     \u2502  PHASE 3        \u2502\n\u2502  Implement      \u2502 \u2500\u2500\u25b6 \u2502  Signal Done    \u2502 \u2500\u2500\u25b6 \u2502  Vote           \u2502\n\u2502  (work alone)   \u2502     \u2502  (coordinate)   \u2502     \u2502  (after ALL done)\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n---\n\n## Phase 1: Implementation\n\n> **CRITICAL**: You MUST commit your changes before proceeding to Phase 2. The merge will FAIL if you have uncommitted changes.\n\n### Development Approach: Test-Driven Development (TDD)\n\nWhen applicable, follow TDD:\n1. **Write tests FIRST** - Define expected behavior before implementation\n2. **Run tests** - Verify they fail (red)\n3. **Implement** - Write minimal code to pass tests\n4. **Run tests again** - Verify they pass (green)\n5. **Refactor** - Clean up while keeping tests green\n\n### Implementation Steps\n\n1. **Understand the task** - Read requirements carefully\n2. **Write tests first** (when applicable) - Define expected behavior\n3. **Implement your solution** - Write clean, working code\n4. **Run tests** - Ensure everything passes\n5. **COMMIT your changes** - This is MANDATORY\n\n### Git Commit Requirements\n\n> \u26a0\ufe0f **WARNING**: You MUST commit before calling `finished_work`. Uncommitted changes will cause merge failures.\n\n```bash\n# Stage your changes\ngit add -A\n\n# Commit with a clear, descriptive message\ngit commit -m \"feat: <brief description of what you implemented>\n\n- <bullet point of key change 1>\n- <bullet point of key change 2>\n- <bullet point of key change 3>\"\n```\n\n**Commit Message Guidelines**:\n- Use conventional commit format: `feat:`, `fix:`, `refactor:`, `test:`\n- First line: Brief summary (50 chars max)\n- Body: Bullet points explaining key changes\n- Be specific about WHAT changed and WHY\n\n### Quality Checklist (Your Competitors Will Check All of These)\n\nBefore committing, verify - **because the other agents WILL**:\n- [ ] All tests pass (run the test suite) - *broken tests = instant loss*\n- [ ] Code compiles/runs without errors - *crashes = instant loss*\n- [ ] Edge cases are handled - *fragile code loses to robust code*\n- [ ] Error handling is included - *unhandled errors = amateur work*\n- [ ] Code is readable and maintainable - *clever hacks lose to clean code*\n- [ ] Changes are committed (not just staged) - *uncommitted = disqualified*\n\n> **Ask yourself**: If a smart, critical reviewer looked at my code, would they find flaws? Fix them NOW, before voting.\n\n### Verify Your Commit\n\n```bash\n# Check that changes are committed (should show nothing to commit)\ngit status\n\n# Verify your commit exists\ngit log -1 --oneline\n```\n\n**DO NOT** proceed to Phase 2 until:\n1. All tests pass\n2. Your changes are COMMITTED (not just staged)\n3. `git status` shows a clean working tree\n\n---\n\n## Phase 2: Signal Completion\n\n> **CRITICAL**: You MUST call `finished_work` after committing. Other agents are waiting.\n\n### Step 1: Get Your Diff\n```bash\ngit diff HEAD~1\n```\n\n### Step 2: Call the MCP Tool\n```\nfinished_work(\n    task_id=\"add-opencode-agent-backend-0b1f3631\",\n    agent_id=\"add-opencode-agent-backend-0b1f3631-agent-1\",\n    implementation=\"<paste your git diff here>\"\n)\n```\n\n### Understanding the Response\nThe tool returns:\n```json\n{\n    \"success\": true,\n    \"agents_remaining\": 2,\n    \"all_finished\": false\n}\n```\n\n- `agents_remaining`: How many agents haven't finished yet\n- `all_finished`: `true` when ALL agents are done\n\n### What To Do Next\n\n| `all_finished` | Action |\n|----------------|--------|\n| `false` | **WAIT** using `sleep 30`, then poll `get_all_implementations` |\n| `true` | **PROCEED** to Phase 3 immediately |\n\n---\n\n## Phase 2.5: Waiting for Other Agents\n\n> **IMPORTANT**: Other agents work CONCURRENTLY. You must wait for them.\n> **DO NOT** call `get_all_implementations` immediately after `finished_work` - use `sleep` first!\n\n### Polling Strategy\n\n**CRITICAL**: Always sleep BEFORE polling, not after. This gives other agents time to finish.\n\n```bash\n# Step 1: Sleep first (REQUIRED - do not skip!)\nsleep 30\n\n# Step 2: Then check if all agents are done\nget_all_implementations(task_id=\"add-opencode-agent-backend-0b1f3631\")\n\n# Step 3: If not all finished, sleep and retry\n# Repeat until success\n```\n\n### Example Workflow\n```bash\n# After calling finished_work, WAIT before polling:\nsleep 30\n\n# Then call the MCP tool:\nget_all_implementations(task_id=\"add-opencode-agent-backend-0b1f3631\")\n\n# If it fails (others not done), sleep again and retry:\nsleep 30\nget_all_implementations(task_id=\"add-opencode-agent-backend-0b1f3631\")\n```\n\n**If it returns an error** like `\"Not all agents have finished yet (2/3)\"`:\n- This is NORMAL - other agents are still working\n- Run `sleep 30` in your terminal\n- Try `get_all_implementations` again\n\n**If it returns success** with implementations:\n- All agents are done\n- Proceed to Phase 3\n\n---\n\n## Phase 3: Review and Vote\n\n> **CRITICAL**: Only proceed here when `get_all_implementations` succeeds.\n\n### Step 1: Quick Scan (Use the Summary!)\n\nThe `get_all_implementations` response provides **structured summaries** for quick comparison:\n\n```json\n{\n    \"success\": true,\n    \"implementations\": [\n        {\n            \"agent_id\": \"add-opencode-agent-backend-0b1f3631-agent-0\",\n            \"session_name\": \"add-opencode-agent-backend-0b1f3631-agent-0\",\n            \"summary\": {\n                \"files_changed\": [\"src/foo.py\", \"tests/test_foo.py\"],\n                \"stats\": {\n                    \"files_count\": 2,\n                    \"added\": 48,\n                    \"deleted\": 12,\n                    \"total\": 60\n                }\n            },\n            \"condensed_diff\": \"diff --git a/src/foo.py...\\n+new code\\n-old code\"\n        }\n    ]\n}\n```\n\n**Build a comparison table mentally:**\n\n| Agent | Files | +Added | -Deleted | Total Changes |\n|-------|-------|--------|----------|---------------|\n| agent-0 | 2 | +48 | -12 | 60 |\n| agent-1 | 5 | +120 | -45 | 165 |\n| agent-2 | 2 | +30 | -8 | 38 |\n\n**Quick red flags:**\n- \u274c Too many files changed = over-engineered\n- \u274c High total changes for simple task = bloated\n- \u2b50 Minimal changes that solve the problem = elegant\n\n### Step 2: Review Condensed Diffs\n\nThe `condensed_diff` field contains a **minimal diff** with:\n- No context lines (only changed lines)\n- Normalized whitespace\n- File headers preserved\n\nThis is much smaller than full git diff - focus on **what actually changed**.\n\n### Step 3: Evaluate Each Solution\n\n**Vote for the solution that best balances these criteria:**\n\n| Criteria | Question to Ask | Red Flags |\n|----------|-----------------|-----------|\n| **Correctness** | Does it actually solve the problem? | Fails tests, wrong output, crashes |\n| **Completeness** | Are ALL requirements met? | Missing features, partial implementation |\n| **Elegance** | Is it the *smartest* solution? | Over-engineered, too many abstractions |\n| **Minimalism** | Does it do exactly what's needed? | Unnecessary code, boilerplate, dead paths |\n| **Robustness** | Does it handle *real* edge cases? | Fragile, unhandled errors |\n\n> **Prefer**: A 50-line solution that works perfectly over a 500-line \"enterprise\" solution.\n> **Penalize**: Over-engineering, unnecessary abstractions, speculative features, verbose comments on obvious code.\n\n### Step 4: Cast Your Vote\n```\ncast_vote(\n    task_id=\"add-opencode-agent-backend-0b1f3631\",\n    agent_id=\"add-opencode-agent-backend-0b1f3631-agent-1\",\n    voted_for=\"<agent_id of the BEST implementation>\",\n    reason=\"<brief explanation - 1-2 sentences>\"\n)\n```\n\n**RULES**:\n- You CANNOT vote for yourself - the system will reject self-votes\n- You MUST vote for exactly ONE other agent\n- Your vote is FINAL - no changes allowed\n- Be OBJECTIVE - vote for the best implementation among your competitors\n\n---\n\n## MCP Tools Reference\n\n### `finished_work`\nSignal that you completed your implementation.\n```\nfinished_work(\n    task_id: string,      # Your task ID\n    agent_id: string,     # Your agent ID\n    implementation: string # Your git diff\n)\n```\n\n### `get_all_implementations`\nGet all agents' implementations (only works when all are done).\n```\nget_all_implementations(\n    task_id: string       # Your task ID\n)\n```\n\n### `cast_vote`\nVote for the best implementation.\n```\ncast_vote(\n    task_id: string,      # Your task ID\n    agent_id: string,     # Your agent ID\n    voted_for: string,    # Agent ID you're voting for\n    reason: string        # Why this is the best\n)\n```\n\n### `get_vote_results`\nCheck voting status (optional, for debugging).\n```\nget_vote_results(\n    task_id: string       # Your task ID\n)\n```\n\n---\n\n## Error Handling\n\n### \"Task not found\"\n- Check your `task_id` is exactly: `add-opencode-agent-backend-0b1f3631`\n- Do not modify or guess the ID\n\n### \"Agent not found\"\n- Check your `agent_id` is exactly: `add-opencode-agent-backend-0b1f3631-agent-1`\n- Do not modify or guess the ID\n\n### \"Not all agents have finished\"\n- This is NORMAL during the waiting period\n- Wait 10-15 seconds and retry\n\n### \"Already voted\"\n- You can only vote once\n- Your vote has been recorded\n\n---\n\n## Timeline Example\n\n```\nTime    Agent-0          Agent-1          Agent-2\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n0:00    Start impl       Start impl       Start impl\n0:45    Still working    Finish impl      Still working\n0:46                     finished_work (2 remaining)\n0:47                     sleep 30...\n1:00    Finish impl                       Still working\n1:01    finished_work (1 remaining)\n1:17                     get_all (fail)\n1:17                     sleep 30...\n1:31                                      Finish impl\n1:32    sleep 30...                       finished_work (0!)\n1:47                     get_all \u2713\n1:48    (wakes up)                        sleep 30...\n2:02    get_all \u2713\n2:18                                      get_all \u2713\n2:20    Review & vote    Review & vote    Review & vote\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        CONSENSUS REACHED - Winner determined\n```\n\n---\n\n## Summary Checklist\n\n- [ ] **Phase 1**: Implement and commit your solution\n- [ ] **Phase 2**: Call `finished_work` with your diff\n- [ ] **Phase 2.5**: Run `sleep 30`, then poll `get_all_implementations` (repeat until success)\n- [ ] **Phase 3**: Review all solutions and call `cast_vote`\n\n---\n\n## Final Reminder: This Is A Competition\n\n> **5 agents. 5 implementations. Only 1 winner.**\n>\n> The other agents are skilled, thorough, and motivated. They will scrutinize your code for any weakness. A single failing test, an unhandled edge case, or sloppy code could cost you the win.\n>\n> **Don't just finish. Win.**\n\n---\n\n**START NOW**: Begin with Phase 1 - implement the task above.\n",
      "pid": null
    },
    {
      "name": "add-opencode-agent-backend-0b1f3631-agent-2",
      "status": "running",
      "branch": "git-native/add-opencode-agent-backend-0b1f3631-agent-2",
      "worktree_path": "/Users/rayen.faleh/swarm/.swarm/worktrees/add-opencode-agent-backend-0b1f3631-agent-2",
      "created_at": "2025-12-18T14:30:58.791198+00:00",
      "spec_content": "# Task\n\n# Task: Add OpenCode CLI agent backend\n\n## Description\nCreate OpenCodeCLIAgentBackend following GitNativeAgentBackend pattern for spawning opencode agents via subprocess\n\n## Scope\n- **Target files**: src/swarm_orchestrator/backends/opencode.py, tests/test_opencode_backend.py\n- **Estimated scope**: ~100 lines of code\n- **Focus areas**: OpenCodeCLIAgentBackend.__init__, OpenCodeCLIAgentBackend.spawn_agent, OpenCodeCLIAgentBackend.wait_for_completion, OpenCodeCLIAgentBackend.send_message, OpenCodeCLIAgentBackend.get_status\n\n## Implementation Goal\nCreate OpenCodeCLIAgentBackend class implementing AgentBackend interface - spawn agents using 'opencode run' with prompt written to .swarm-prompt.md file, track processes in _processes dict, use subprocess.Popen for async execution with -q flag for quiet mode\n\n## Verification Requirements\nUnit tests for spawn_agent writing prompt file and starting process, wait_for_completion with timeout handling, get_status returning correct finished state, send_message raising NotImplementedError (opencode CLI limitation)\n\n## Success Criteria\n- [ ] OpenCodeCLIAgentBackend implements all AgentBackend abstract methods\n- [ ] spawn_agent creates .swarm-prompt.md and starts opencode process\n- [ ] wait_for_completion handles timeout and returns AgentStatus correctly\n- [ ] Unit tests pass\n\n## Important Guidelines\n- Stay within the specified scope - avoid modifying unrelated files\n- Include tests as part of your implementation\n- Commit when all success criteria are met\n- Prefer minimal, focused changes over large refactors\n\n\n## Exploration Context\nOpenCode integration requires two new backends: OpenCodeCLIAgentBackend (spawning agents via 'opencode -p <prompt> -q') following the GitNativeAgentBackend pattern, and OpenCodeCLIBackend for LLM calls (using 'opencode -p <prompt> -f json') following ClaudeCLIBackend. Both use subprocess with non-interactive -p flag. Must update config.py BACKENDS registry and backends/__init__.py exports.\n\n## Relevant Files\n- **src/swarm_orchestrator/backends/base.py**: Abstract base classes defining AgentBackend and LLMBackend interfaces that opencode implementations must follow (patterns: ABC abstract interface, spawn_agent/wait_for_completion/send_message/get_status methods for AgentBackend, decompose/explore methods for LLMBackend)\n- **src/swarm_orchestrator/backends/git_native.py**: Reference implementation of AgentBackend using Claude CLI - spawns agents via subprocess with -p flag and --dangerously-skip-permissions (patterns: subprocess.Popen for async agent spawning, prompt written to .swarm-prompt.md file, _processes dict tracking running agents, communicate() for completion waiting)\n- **src/swarm_orchestrator/backends/llm.py**: LLM backend implementations - ClaudeCLIBackend uses 'claude -p prompt --output-format text' pattern for non-interactive CLI calls (patterns: subprocess.run for synchronous CLI calls, _call_cli abstraction, _parse_decompose_response for JSON extraction, timeout handling)\n- **src/swarm_orchestrator/config.py**: Configuration system with BACKENDS registry - defines valid backend choices and SwarmConfig dataclass (patterns: BACKENDS dict with 'agent' and 'llm' keys for registering new backends, get_backend_choices function, SwarmConfig.from_dict/to_dict for serialization)\n- **src/swarm_orchestrator/backends/__init__.py**: Backend exports - new implementations must be imported and added to __all__ (patterns: Explicit imports from implementation modules, __all__ list for public API)\n\n## Reference Documentation\n- [https://github.com/opencode-ai/opencode](https://github.com/opencode-ai/opencode): OpenCode is a Go-based AI coding assistant CLI. Supports -p flag for non-interactive mode: 'opencode -p \"prompt\"'. Also supports -f json for JSON output and -q/--quiet flag for scripts. Has --allowedTools and --excludedTools flags for tool control.\n- [https://opencode.ai/docs/cli/](https://opencode.ai/docs/cli/): OpenCode CLI docs show non-interactive mode auto-approves all permissions. Supports multiple AI providers (OpenAI, Anthropic, Gemini, Groq, etc). Can run 'opencode serve' for headless API server.\n- [https://github.com/opencode-ai/opencode/issues/277](https://github.com/opencode-ai/opencode/issues/277): Known limitation: cannot specify model when using -p flag in non-interactive mode. Issue open for model selection in CLI.\n\n---\n\n# CRITICAL: Swarm Agent Coordination\n\nYou are **Agent `add-opencode-agent-backend-0b1f3631-agent-2`** working on **Task `add-opencode-agent-backend-0b1f3631`** as part of a 5-agent swarm.\n\n> **CRITICAL**: You are one of multiple agents working on the same task concurrently. Follow these instructions EXACTLY to coordinate with other agents.\n\n---\n\n## The Stakes: Winner Takes All\n\nYou are competing against **5 highly capable AI agents** - all working on the exact same task. When everyone finishes:\n\n1. **Every agent reviews ALL implementations** (including yours)\n2. **Every agent votes** for the best solution\n3. **Majority wins** - that implementation gets merged\n4. **All others are DISCARDED** - their work is deleted\n\n### What This Means For You\n\n| If You Win | If You Lose |\n|------------|-------------|\n| Your code gets merged | Your code is **deleted** |\n| Your solution ships | Your work was for nothing |\n| You solved the problem | You wasted the effort |\n\n### How To Win\n\nThe agents judging your work are **smart and thorough**. They will evaluate:\n\n- **Does it actually work?** - Broken code loses immediately\n- **Is it complete?** - Partial solutions lose to complete ones\n- **Is it well-tested?** - Untested code is risky, tested code wins\n- **Is it clean?** - Readable, maintainable code beats clever hacks\n- **Does it handle edge cases?** - Robust solutions beat fragile ones\n\n### How To Lose\n\n**Over-engineering is a losing strategy.** The reviewers will penalize:\n\n- **Unnecessary abstractions** - Don't create helpers for one-time operations\n- **Excessive boilerplate** - More code = more bugs = more risk\n- **Features nobody asked for** - Solve the task, not imaginary future requirements\n- **Verbose comments on obvious code** - If the code needs that many comments, simplify it\n- **\"Just in case\" code** - Dead code paths, unused parameters, speculative features\n- **Gold-plating** - Perfect is the enemy of done\n\n> **The winning formula**: Solve the problem **exactly**. Not 80% of it. Not 150% of it. **100%** - complete, working, and nothing more.\n\n### What Reviewers Are Looking For\n\n```\n\u274c LOSES                              \u2705 WINS\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n500 lines with abstractions          50 lines that just work\n\"Flexible\" and \"extensible\"          Focused and purposeful\nHandles hypothetical edge cases      Handles real edge cases\nComments explaining the obvious      Self-documenting code\nFactory factories                    Direct implementation\n\"Production ready\" boilerplate       Clean, minimal solution\n```\n\n> **Bottom line**: The best code is code that doesn't exist. Every line you write is a liability. Write exactly what's needed - creative, elegant, minimal - and ship it. **The smartest solution wins, not the longest.**\n\n---\n\n## Your Identity\n\n| Field | Value |\n|-------|-------|\n| task_id | `add-opencode-agent-backend-0b1f3631` |\n| agent_id | `add-opencode-agent-backend-0b1f3631-agent-2` |\n| agent_count | 5 |\n\n**IMPORTANT**: Always use these EXACT IDs when calling MCP tools. Do not modify or guess IDs.\n\n---\n\n## Workflow Overview\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  PHASE 1        \u2502     \u2502  PHASE 2        \u2502     \u2502  PHASE 3        \u2502\n\u2502  Implement      \u2502 \u2500\u2500\u25b6 \u2502  Signal Done    \u2502 \u2500\u2500\u25b6 \u2502  Vote           \u2502\n\u2502  (work alone)   \u2502     \u2502  (coordinate)   \u2502     \u2502  (after ALL done)\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n---\n\n## Phase 1: Implementation\n\n> **CRITICAL**: You MUST commit your changes before proceeding to Phase 2. The merge will FAIL if you have uncommitted changes.\n\n### Development Approach: Test-Driven Development (TDD)\n\nWhen applicable, follow TDD:\n1. **Write tests FIRST** - Define expected behavior before implementation\n2. **Run tests** - Verify they fail (red)\n3. **Implement** - Write minimal code to pass tests\n4. **Run tests again** - Verify they pass (green)\n5. **Refactor** - Clean up while keeping tests green\n\n### Implementation Steps\n\n1. **Understand the task** - Read requirements carefully\n2. **Write tests first** (when applicable) - Define expected behavior\n3. **Implement your solution** - Write clean, working code\n4. **Run tests** - Ensure everything passes\n5. **COMMIT your changes** - This is MANDATORY\n\n### Git Commit Requirements\n\n> \u26a0\ufe0f **WARNING**: You MUST commit before calling `finished_work`. Uncommitted changes will cause merge failures.\n\n```bash\n# Stage your changes\ngit add -A\n\n# Commit with a clear, descriptive message\ngit commit -m \"feat: <brief description of what you implemented>\n\n- <bullet point of key change 1>\n- <bullet point of key change 2>\n- <bullet point of key change 3>\"\n```\n\n**Commit Message Guidelines**:\n- Use conventional commit format: `feat:`, `fix:`, `refactor:`, `test:`\n- First line: Brief summary (50 chars max)\n- Body: Bullet points explaining key changes\n- Be specific about WHAT changed and WHY\n\n### Quality Checklist (Your Competitors Will Check All of These)\n\nBefore committing, verify - **because the other agents WILL**:\n- [ ] All tests pass (run the test suite) - *broken tests = instant loss*\n- [ ] Code compiles/runs without errors - *crashes = instant loss*\n- [ ] Edge cases are handled - *fragile code loses to robust code*\n- [ ] Error handling is included - *unhandled errors = amateur work*\n- [ ] Code is readable and maintainable - *clever hacks lose to clean code*\n- [ ] Changes are committed (not just staged) - *uncommitted = disqualified*\n\n> **Ask yourself**: If a smart, critical reviewer looked at my code, would they find flaws? Fix them NOW, before voting.\n\n### Verify Your Commit\n\n```bash\n# Check that changes are committed (should show nothing to commit)\ngit status\n\n# Verify your commit exists\ngit log -1 --oneline\n```\n\n**DO NOT** proceed to Phase 2 until:\n1. All tests pass\n2. Your changes are COMMITTED (not just staged)\n3. `git status` shows a clean working tree\n\n---\n\n## Phase 2: Signal Completion\n\n> **CRITICAL**: You MUST call `finished_work` after committing. Other agents are waiting.\n\n### Step 1: Get Your Diff\n```bash\ngit diff HEAD~1\n```\n\n### Step 2: Call the MCP Tool\n```\nfinished_work(\n    task_id=\"add-opencode-agent-backend-0b1f3631\",\n    agent_id=\"add-opencode-agent-backend-0b1f3631-agent-2\",\n    implementation=\"<paste your git diff here>\"\n)\n```\n\n### Understanding the Response\nThe tool returns:\n```json\n{\n    \"success\": true,\n    \"agents_remaining\": 2,\n    \"all_finished\": false\n}\n```\n\n- `agents_remaining`: How many agents haven't finished yet\n- `all_finished`: `true` when ALL agents are done\n\n### What To Do Next\n\n| `all_finished` | Action |\n|----------------|--------|\n| `false` | **WAIT** using `sleep 30`, then poll `get_all_implementations` |\n| `true` | **PROCEED** to Phase 3 immediately |\n\n---\n\n## Phase 2.5: Waiting for Other Agents\n\n> **IMPORTANT**: Other agents work CONCURRENTLY. You must wait for them.\n> **DO NOT** call `get_all_implementations` immediately after `finished_work` - use `sleep` first!\n\n### Polling Strategy\n\n**CRITICAL**: Always sleep BEFORE polling, not after. This gives other agents time to finish.\n\n```bash\n# Step 1: Sleep first (REQUIRED - do not skip!)\nsleep 30\n\n# Step 2: Then check if all agents are done\nget_all_implementations(task_id=\"add-opencode-agent-backend-0b1f3631\")\n\n# Step 3: If not all finished, sleep and retry\n# Repeat until success\n```\n\n### Example Workflow\n```bash\n# After calling finished_work, WAIT before polling:\nsleep 30\n\n# Then call the MCP tool:\nget_all_implementations(task_id=\"add-opencode-agent-backend-0b1f3631\")\n\n# If it fails (others not done), sleep again and retry:\nsleep 30\nget_all_implementations(task_id=\"add-opencode-agent-backend-0b1f3631\")\n```\n\n**If it returns an error** like `\"Not all agents have finished yet (2/3)\"`:\n- This is NORMAL - other agents are still working\n- Run `sleep 30` in your terminal\n- Try `get_all_implementations` again\n\n**If it returns success** with implementations:\n- All agents are done\n- Proceed to Phase 3\n\n---\n\n## Phase 3: Review and Vote\n\n> **CRITICAL**: Only proceed here when `get_all_implementations` succeeds.\n\n### Step 1: Quick Scan (Use the Summary!)\n\nThe `get_all_implementations` response provides **structured summaries** for quick comparison:\n\n```json\n{\n    \"success\": true,\n    \"implementations\": [\n        {\n            \"agent_id\": \"add-opencode-agent-backend-0b1f3631-agent-0\",\n            \"session_name\": \"add-opencode-agent-backend-0b1f3631-agent-0\",\n            \"summary\": {\n                \"files_changed\": [\"src/foo.py\", \"tests/test_foo.py\"],\n                \"stats\": {\n                    \"files_count\": 2,\n                    \"added\": 48,\n                    \"deleted\": 12,\n                    \"total\": 60\n                }\n            },\n            \"condensed_diff\": \"diff --git a/src/foo.py...\\n+new code\\n-old code\"\n        }\n    ]\n}\n```\n\n**Build a comparison table mentally:**\n\n| Agent | Files | +Added | -Deleted | Total Changes |\n|-------|-------|--------|----------|---------------|\n| agent-0 | 2 | +48 | -12 | 60 |\n| agent-1 | 5 | +120 | -45 | 165 |\n| agent-2 | 2 | +30 | -8 | 38 |\n\n**Quick red flags:**\n- \u274c Too many files changed = over-engineered\n- \u274c High total changes for simple task = bloated\n- \u2b50 Minimal changes that solve the problem = elegant\n\n### Step 2: Review Condensed Diffs\n\nThe `condensed_diff` field contains a **minimal diff** with:\n- No context lines (only changed lines)\n- Normalized whitespace\n- File headers preserved\n\nThis is much smaller than full git diff - focus on **what actually changed**.\n\n### Step 3: Evaluate Each Solution\n\n**Vote for the solution that best balances these criteria:**\n\n| Criteria | Question to Ask | Red Flags |\n|----------|-----------------|-----------|\n| **Correctness** | Does it actually solve the problem? | Fails tests, wrong output, crashes |\n| **Completeness** | Are ALL requirements met? | Missing features, partial implementation |\n| **Elegance** | Is it the *smartest* solution? | Over-engineered, too many abstractions |\n| **Minimalism** | Does it do exactly what's needed? | Unnecessary code, boilerplate, dead paths |\n| **Robustness** | Does it handle *real* edge cases? | Fragile, unhandled errors |\n\n> **Prefer**: A 50-line solution that works perfectly over a 500-line \"enterprise\" solution.\n> **Penalize**: Over-engineering, unnecessary abstractions, speculative features, verbose comments on obvious code.\n\n### Step 4: Cast Your Vote\n```\ncast_vote(\n    task_id=\"add-opencode-agent-backend-0b1f3631\",\n    agent_id=\"add-opencode-agent-backend-0b1f3631-agent-2\",\n    voted_for=\"<agent_id of the BEST implementation>\",\n    reason=\"<brief explanation - 1-2 sentences>\"\n)\n```\n\n**RULES**:\n- You CANNOT vote for yourself - the system will reject self-votes\n- You MUST vote for exactly ONE other agent\n- Your vote is FINAL - no changes allowed\n- Be OBJECTIVE - vote for the best implementation among your competitors\n\n---\n\n## MCP Tools Reference\n\n### `finished_work`\nSignal that you completed your implementation.\n```\nfinished_work(\n    task_id: string,      # Your task ID\n    agent_id: string,     # Your agent ID\n    implementation: string # Your git diff\n)\n```\n\n### `get_all_implementations`\nGet all agents' implementations (only works when all are done).\n```\nget_all_implementations(\n    task_id: string       # Your task ID\n)\n```\n\n### `cast_vote`\nVote for the best implementation.\n```\ncast_vote(\n    task_id: string,      # Your task ID\n    agent_id: string,     # Your agent ID\n    voted_for: string,    # Agent ID you're voting for\n    reason: string        # Why this is the best\n)\n```\n\n### `get_vote_results`\nCheck voting status (optional, for debugging).\n```\nget_vote_results(\n    task_id: string       # Your task ID\n)\n```\n\n---\n\n## Error Handling\n\n### \"Task not found\"\n- Check your `task_id` is exactly: `add-opencode-agent-backend-0b1f3631`\n- Do not modify or guess the ID\n\n### \"Agent not found\"\n- Check your `agent_id` is exactly: `add-opencode-agent-backend-0b1f3631-agent-2`\n- Do not modify or guess the ID\n\n### \"Not all agents have finished\"\n- This is NORMAL during the waiting period\n- Wait 10-15 seconds and retry\n\n### \"Already voted\"\n- You can only vote once\n- Your vote has been recorded\n\n---\n\n## Timeline Example\n\n```\nTime    Agent-0          Agent-1          Agent-2\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n0:00    Start impl       Start impl       Start impl\n0:45    Still working    Finish impl      Still working\n0:46                     finished_work (2 remaining)\n0:47                     sleep 30...\n1:00    Finish impl                       Still working\n1:01    finished_work (1 remaining)\n1:17                     get_all (fail)\n1:17                     sleep 30...\n1:31                                      Finish impl\n1:32    sleep 30...                       finished_work (0!)\n1:47                     get_all \u2713\n1:48    (wakes up)                        sleep 30...\n2:02    get_all \u2713\n2:18                                      get_all \u2713\n2:20    Review & vote    Review & vote    Review & vote\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        CONSENSUS REACHED - Winner determined\n```\n\n---\n\n## Summary Checklist\n\n- [ ] **Phase 1**: Implement and commit your solution\n- [ ] **Phase 2**: Call `finished_work` with your diff\n- [ ] **Phase 2.5**: Run `sleep 30`, then poll `get_all_implementations` (repeat until success)\n- [ ] **Phase 3**: Review all solutions and call `cast_vote`\n\n---\n\n## Final Reminder: This Is A Competition\n\n> **5 agents. 5 implementations. Only 1 winner.**\n>\n> The other agents are skilled, thorough, and motivated. They will scrutinize your code for any weakness. A single failing test, an unhandled edge case, or sloppy code could cost you the win.\n>\n> **Don't just finish. Win.**\n\n---\n\n**START NOW**: Begin with Phase 1 - implement the task above.\n",
      "pid": null
    },
    {
      "name": "add-opencode-agent-backend-0b1f3631-agent-3",
      "status": "running",
      "branch": "git-native/add-opencode-agent-backend-0b1f3631-agent-3",
      "worktree_path": "/Users/rayen.faleh/swarm/.swarm/worktrees/add-opencode-agent-backend-0b1f3631-agent-3",
      "created_at": "2025-12-18T14:30:58.857288+00:00",
      "spec_content": "# Task\n\n# Task: Add OpenCode CLI agent backend\n\n## Description\nCreate OpenCodeCLIAgentBackend following GitNativeAgentBackend pattern for spawning opencode agents via subprocess\n\n## Scope\n- **Target files**: src/swarm_orchestrator/backends/opencode.py, tests/test_opencode_backend.py\n- **Estimated scope**: ~100 lines of code\n- **Focus areas**: OpenCodeCLIAgentBackend.__init__, OpenCodeCLIAgentBackend.spawn_agent, OpenCodeCLIAgentBackend.wait_for_completion, OpenCodeCLIAgentBackend.send_message, OpenCodeCLIAgentBackend.get_status\n\n## Implementation Goal\nCreate OpenCodeCLIAgentBackend class implementing AgentBackend interface - spawn agents using 'opencode run' with prompt written to .swarm-prompt.md file, track processes in _processes dict, use subprocess.Popen for async execution with -q flag for quiet mode\n\n## Verification Requirements\nUnit tests for spawn_agent writing prompt file and starting process, wait_for_completion with timeout handling, get_status returning correct finished state, send_message raising NotImplementedError (opencode CLI limitation)\n\n## Success Criteria\n- [ ] OpenCodeCLIAgentBackend implements all AgentBackend abstract methods\n- [ ] spawn_agent creates .swarm-prompt.md and starts opencode process\n- [ ] wait_for_completion handles timeout and returns AgentStatus correctly\n- [ ] Unit tests pass\n\n## Important Guidelines\n- Stay within the specified scope - avoid modifying unrelated files\n- Include tests as part of your implementation\n- Commit when all success criteria are met\n- Prefer minimal, focused changes over large refactors\n\n\n## Exploration Context\nOpenCode integration requires two new backends: OpenCodeCLIAgentBackend (spawning agents via 'opencode -p <prompt> -q') following the GitNativeAgentBackend pattern, and OpenCodeCLIBackend for LLM calls (using 'opencode -p <prompt> -f json') following ClaudeCLIBackend. Both use subprocess with non-interactive -p flag. Must update config.py BACKENDS registry and backends/__init__.py exports.\n\n## Relevant Files\n- **src/swarm_orchestrator/backends/base.py**: Abstract base classes defining AgentBackend and LLMBackend interfaces that opencode implementations must follow (patterns: ABC abstract interface, spawn_agent/wait_for_completion/send_message/get_status methods for AgentBackend, decompose/explore methods for LLMBackend)\n- **src/swarm_orchestrator/backends/git_native.py**: Reference implementation of AgentBackend using Claude CLI - spawns agents via subprocess with -p flag and --dangerously-skip-permissions (patterns: subprocess.Popen for async agent spawning, prompt written to .swarm-prompt.md file, _processes dict tracking running agents, communicate() for completion waiting)\n- **src/swarm_orchestrator/backends/llm.py**: LLM backend implementations - ClaudeCLIBackend uses 'claude -p prompt --output-format text' pattern for non-interactive CLI calls (patterns: subprocess.run for synchronous CLI calls, _call_cli abstraction, _parse_decompose_response for JSON extraction, timeout handling)\n- **src/swarm_orchestrator/config.py**: Configuration system with BACKENDS registry - defines valid backend choices and SwarmConfig dataclass (patterns: BACKENDS dict with 'agent' and 'llm' keys for registering new backends, get_backend_choices function, SwarmConfig.from_dict/to_dict for serialization)\n- **src/swarm_orchestrator/backends/__init__.py**: Backend exports - new implementations must be imported and added to __all__ (patterns: Explicit imports from implementation modules, __all__ list for public API)\n\n## Reference Documentation\n- [https://github.com/opencode-ai/opencode](https://github.com/opencode-ai/opencode): OpenCode is a Go-based AI coding assistant CLI. Supports -p flag for non-interactive mode: 'opencode -p \"prompt\"'. Also supports -f json for JSON output and -q/--quiet flag for scripts. Has --allowedTools and --excludedTools flags for tool control.\n- [https://opencode.ai/docs/cli/](https://opencode.ai/docs/cli/): OpenCode CLI docs show non-interactive mode auto-approves all permissions. Supports multiple AI providers (OpenAI, Anthropic, Gemini, Groq, etc). Can run 'opencode serve' for headless API server.\n- [https://github.com/opencode-ai/opencode/issues/277](https://github.com/opencode-ai/opencode/issues/277): Known limitation: cannot specify model when using -p flag in non-interactive mode. Issue open for model selection in CLI.\n\n---\n\n# CRITICAL: Swarm Agent Coordination\n\nYou are **Agent `add-opencode-agent-backend-0b1f3631-agent-3`** working on **Task `add-opencode-agent-backend-0b1f3631`** as part of a 5-agent swarm.\n\n> **CRITICAL**: You are one of multiple agents working on the same task concurrently. Follow these instructions EXACTLY to coordinate with other agents.\n\n---\n\n## The Stakes: Winner Takes All\n\nYou are competing against **5 highly capable AI agents** - all working on the exact same task. When everyone finishes:\n\n1. **Every agent reviews ALL implementations** (including yours)\n2. **Every agent votes** for the best solution\n3. **Majority wins** - that implementation gets merged\n4. **All others are DISCARDED** - their work is deleted\n\n### What This Means For You\n\n| If You Win | If You Lose |\n|------------|-------------|\n| Your code gets merged | Your code is **deleted** |\n| Your solution ships | Your work was for nothing |\n| You solved the problem | You wasted the effort |\n\n### How To Win\n\nThe agents judging your work are **smart and thorough**. They will evaluate:\n\n- **Does it actually work?** - Broken code loses immediately\n- **Is it complete?** - Partial solutions lose to complete ones\n- **Is it well-tested?** - Untested code is risky, tested code wins\n- **Is it clean?** - Readable, maintainable code beats clever hacks\n- **Does it handle edge cases?** - Robust solutions beat fragile ones\n\n### How To Lose\n\n**Over-engineering is a losing strategy.** The reviewers will penalize:\n\n- **Unnecessary abstractions** - Don't create helpers for one-time operations\n- **Excessive boilerplate** - More code = more bugs = more risk\n- **Features nobody asked for** - Solve the task, not imaginary future requirements\n- **Verbose comments on obvious code** - If the code needs that many comments, simplify it\n- **\"Just in case\" code** - Dead code paths, unused parameters, speculative features\n- **Gold-plating** - Perfect is the enemy of done\n\n> **The winning formula**: Solve the problem **exactly**. Not 80% of it. Not 150% of it. **100%** - complete, working, and nothing more.\n\n### What Reviewers Are Looking For\n\n```\n\u274c LOSES                              \u2705 WINS\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n500 lines with abstractions          50 lines that just work\n\"Flexible\" and \"extensible\"          Focused and purposeful\nHandles hypothetical edge cases      Handles real edge cases\nComments explaining the obvious      Self-documenting code\nFactory factories                    Direct implementation\n\"Production ready\" boilerplate       Clean, minimal solution\n```\n\n> **Bottom line**: The best code is code that doesn't exist. Every line you write is a liability. Write exactly what's needed - creative, elegant, minimal - and ship it. **The smartest solution wins, not the longest.**\n\n---\n\n## Your Identity\n\n| Field | Value |\n|-------|-------|\n| task_id | `add-opencode-agent-backend-0b1f3631` |\n| agent_id | `add-opencode-agent-backend-0b1f3631-agent-3` |\n| agent_count | 5 |\n\n**IMPORTANT**: Always use these EXACT IDs when calling MCP tools. Do not modify or guess IDs.\n\n---\n\n## Workflow Overview\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  PHASE 1        \u2502     \u2502  PHASE 2        \u2502     \u2502  PHASE 3        \u2502\n\u2502  Implement      \u2502 \u2500\u2500\u25b6 \u2502  Signal Done    \u2502 \u2500\u2500\u25b6 \u2502  Vote           \u2502\n\u2502  (work alone)   \u2502     \u2502  (coordinate)   \u2502     \u2502  (after ALL done)\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n---\n\n## Phase 1: Implementation\n\n> **CRITICAL**: You MUST commit your changes before proceeding to Phase 2. The merge will FAIL if you have uncommitted changes.\n\n### Development Approach: Test-Driven Development (TDD)\n\nWhen applicable, follow TDD:\n1. **Write tests FIRST** - Define expected behavior before implementation\n2. **Run tests** - Verify they fail (red)\n3. **Implement** - Write minimal code to pass tests\n4. **Run tests again** - Verify they pass (green)\n5. **Refactor** - Clean up while keeping tests green\n\n### Implementation Steps\n\n1. **Understand the task** - Read requirements carefully\n2. **Write tests first** (when applicable) - Define expected behavior\n3. **Implement your solution** - Write clean, working code\n4. **Run tests** - Ensure everything passes\n5. **COMMIT your changes** - This is MANDATORY\n\n### Git Commit Requirements\n\n> \u26a0\ufe0f **WARNING**: You MUST commit before calling `finished_work`. Uncommitted changes will cause merge failures.\n\n```bash\n# Stage your changes\ngit add -A\n\n# Commit with a clear, descriptive message\ngit commit -m \"feat: <brief description of what you implemented>\n\n- <bullet point of key change 1>\n- <bullet point of key change 2>\n- <bullet point of key change 3>\"\n```\n\n**Commit Message Guidelines**:\n- Use conventional commit format: `feat:`, `fix:`, `refactor:`, `test:`\n- First line: Brief summary (50 chars max)\n- Body: Bullet points explaining key changes\n- Be specific about WHAT changed and WHY\n\n### Quality Checklist (Your Competitors Will Check All of These)\n\nBefore committing, verify - **because the other agents WILL**:\n- [ ] All tests pass (run the test suite) - *broken tests = instant loss*\n- [ ] Code compiles/runs without errors - *crashes = instant loss*\n- [ ] Edge cases are handled - *fragile code loses to robust code*\n- [ ] Error handling is included - *unhandled errors = amateur work*\n- [ ] Code is readable and maintainable - *clever hacks lose to clean code*\n- [ ] Changes are committed (not just staged) - *uncommitted = disqualified*\n\n> **Ask yourself**: If a smart, critical reviewer looked at my code, would they find flaws? Fix them NOW, before voting.\n\n### Verify Your Commit\n\n```bash\n# Check that changes are committed (should show nothing to commit)\ngit status\n\n# Verify your commit exists\ngit log -1 --oneline\n```\n\n**DO NOT** proceed to Phase 2 until:\n1. All tests pass\n2. Your changes are COMMITTED (not just staged)\n3. `git status` shows a clean working tree\n\n---\n\n## Phase 2: Signal Completion\n\n> **CRITICAL**: You MUST call `finished_work` after committing. Other agents are waiting.\n\n### Step 1: Get Your Diff\n```bash\ngit diff HEAD~1\n```\n\n### Step 2: Call the MCP Tool\n```\nfinished_work(\n    task_id=\"add-opencode-agent-backend-0b1f3631\",\n    agent_id=\"add-opencode-agent-backend-0b1f3631-agent-3\",\n    implementation=\"<paste your git diff here>\"\n)\n```\n\n### Understanding the Response\nThe tool returns:\n```json\n{\n    \"success\": true,\n    \"agents_remaining\": 2,\n    \"all_finished\": false\n}\n```\n\n- `agents_remaining`: How many agents haven't finished yet\n- `all_finished`: `true` when ALL agents are done\n\n### What To Do Next\n\n| `all_finished` | Action |\n|----------------|--------|\n| `false` | **WAIT** using `sleep 30`, then poll `get_all_implementations` |\n| `true` | **PROCEED** to Phase 3 immediately |\n\n---\n\n## Phase 2.5: Waiting for Other Agents\n\n> **IMPORTANT**: Other agents work CONCURRENTLY. You must wait for them.\n> **DO NOT** call `get_all_implementations` immediately after `finished_work` - use `sleep` first!\n\n### Polling Strategy\n\n**CRITICAL**: Always sleep BEFORE polling, not after. This gives other agents time to finish.\n\n```bash\n# Step 1: Sleep first (REQUIRED - do not skip!)\nsleep 30\n\n# Step 2: Then check if all agents are done\nget_all_implementations(task_id=\"add-opencode-agent-backend-0b1f3631\")\n\n# Step 3: If not all finished, sleep and retry\n# Repeat until success\n```\n\n### Example Workflow\n```bash\n# After calling finished_work, WAIT before polling:\nsleep 30\n\n# Then call the MCP tool:\nget_all_implementations(task_id=\"add-opencode-agent-backend-0b1f3631\")\n\n# If it fails (others not done), sleep again and retry:\nsleep 30\nget_all_implementations(task_id=\"add-opencode-agent-backend-0b1f3631\")\n```\n\n**If it returns an error** like `\"Not all agents have finished yet (2/3)\"`:\n- This is NORMAL - other agents are still working\n- Run `sleep 30` in your terminal\n- Try `get_all_implementations` again\n\n**If it returns success** with implementations:\n- All agents are done\n- Proceed to Phase 3\n\n---\n\n## Phase 3: Review and Vote\n\n> **CRITICAL**: Only proceed here when `get_all_implementations` succeeds.\n\n### Step 1: Quick Scan (Use the Summary!)\n\nThe `get_all_implementations` response provides **structured summaries** for quick comparison:\n\n```json\n{\n    \"success\": true,\n    \"implementations\": [\n        {\n            \"agent_id\": \"add-opencode-agent-backend-0b1f3631-agent-0\",\n            \"session_name\": \"add-opencode-agent-backend-0b1f3631-agent-0\",\n            \"summary\": {\n                \"files_changed\": [\"src/foo.py\", \"tests/test_foo.py\"],\n                \"stats\": {\n                    \"files_count\": 2,\n                    \"added\": 48,\n                    \"deleted\": 12,\n                    \"total\": 60\n                }\n            },\n            \"condensed_diff\": \"diff --git a/src/foo.py...\\n+new code\\n-old code\"\n        }\n    ]\n}\n```\n\n**Build a comparison table mentally:**\n\n| Agent | Files | +Added | -Deleted | Total Changes |\n|-------|-------|--------|----------|---------------|\n| agent-0 | 2 | +48 | -12 | 60 |\n| agent-1 | 5 | +120 | -45 | 165 |\n| agent-2 | 2 | +30 | -8 | 38 |\n\n**Quick red flags:**\n- \u274c Too many files changed = over-engineered\n- \u274c High total changes for simple task = bloated\n- \u2b50 Minimal changes that solve the problem = elegant\n\n### Step 2: Review Condensed Diffs\n\nThe `condensed_diff` field contains a **minimal diff** with:\n- No context lines (only changed lines)\n- Normalized whitespace\n- File headers preserved\n\nThis is much smaller than full git diff - focus on **what actually changed**.\n\n### Step 3: Evaluate Each Solution\n\n**Vote for the solution that best balances these criteria:**\n\n| Criteria | Question to Ask | Red Flags |\n|----------|-----------------|-----------|\n| **Correctness** | Does it actually solve the problem? | Fails tests, wrong output, crashes |\n| **Completeness** | Are ALL requirements met? | Missing features, partial implementation |\n| **Elegance** | Is it the *smartest* solution? | Over-engineered, too many abstractions |\n| **Minimalism** | Does it do exactly what's needed? | Unnecessary code, boilerplate, dead paths |\n| **Robustness** | Does it handle *real* edge cases? | Fragile, unhandled errors |\n\n> **Prefer**: A 50-line solution that works perfectly over a 500-line \"enterprise\" solution.\n> **Penalize**: Over-engineering, unnecessary abstractions, speculative features, verbose comments on obvious code.\n\n### Step 4: Cast Your Vote\n```\ncast_vote(\n    task_id=\"add-opencode-agent-backend-0b1f3631\",\n    agent_id=\"add-opencode-agent-backend-0b1f3631-agent-3\",\n    voted_for=\"<agent_id of the BEST implementation>\",\n    reason=\"<brief explanation - 1-2 sentences>\"\n)\n```\n\n**RULES**:\n- You CANNOT vote for yourself - the system will reject self-votes\n- You MUST vote for exactly ONE other agent\n- Your vote is FINAL - no changes allowed\n- Be OBJECTIVE - vote for the best implementation among your competitors\n\n---\n\n## MCP Tools Reference\n\n### `finished_work`\nSignal that you completed your implementation.\n```\nfinished_work(\n    task_id: string,      # Your task ID\n    agent_id: string,     # Your agent ID\n    implementation: string # Your git diff\n)\n```\n\n### `get_all_implementations`\nGet all agents' implementations (only works when all are done).\n```\nget_all_implementations(\n    task_id: string       # Your task ID\n)\n```\n\n### `cast_vote`\nVote for the best implementation.\n```\ncast_vote(\n    task_id: string,      # Your task ID\n    agent_id: string,     # Your agent ID\n    voted_for: string,    # Agent ID you're voting for\n    reason: string        # Why this is the best\n)\n```\n\n### `get_vote_results`\nCheck voting status (optional, for debugging).\n```\nget_vote_results(\n    task_id: string       # Your task ID\n)\n```\n\n---\n\n## Error Handling\n\n### \"Task not found\"\n- Check your `task_id` is exactly: `add-opencode-agent-backend-0b1f3631`\n- Do not modify or guess the ID\n\n### \"Agent not found\"\n- Check your `agent_id` is exactly: `add-opencode-agent-backend-0b1f3631-agent-3`\n- Do not modify or guess the ID\n\n### \"Not all agents have finished\"\n- This is NORMAL during the waiting period\n- Wait 10-15 seconds and retry\n\n### \"Already voted\"\n- You can only vote once\n- Your vote has been recorded\n\n---\n\n## Timeline Example\n\n```\nTime    Agent-0          Agent-1          Agent-2\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n0:00    Start impl       Start impl       Start impl\n0:45    Still working    Finish impl      Still working\n0:46                     finished_work (2 remaining)\n0:47                     sleep 30...\n1:00    Finish impl                       Still working\n1:01    finished_work (1 remaining)\n1:17                     get_all (fail)\n1:17                     sleep 30...\n1:31                                      Finish impl\n1:32    sleep 30...                       finished_work (0!)\n1:47                     get_all \u2713\n1:48    (wakes up)                        sleep 30...\n2:02    get_all \u2713\n2:18                                      get_all \u2713\n2:20    Review & vote    Review & vote    Review & vote\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        CONSENSUS REACHED - Winner determined\n```\n\n---\n\n## Summary Checklist\n\n- [ ] **Phase 1**: Implement and commit your solution\n- [ ] **Phase 2**: Call `finished_work` with your diff\n- [ ] **Phase 2.5**: Run `sleep 30`, then poll `get_all_implementations` (repeat until success)\n- [ ] **Phase 3**: Review all solutions and call `cast_vote`\n\n---\n\n## Final Reminder: This Is A Competition\n\n> **5 agents. 5 implementations. Only 1 winner.**\n>\n> The other agents are skilled, thorough, and motivated. They will scrutinize your code for any weakness. A single failing test, an unhandled edge case, or sloppy code could cost you the win.\n>\n> **Don't just finish. Win.**\n\n---\n\n**START NOW**: Begin with Phase 1 - implement the task above.\n",
      "pid": null
    },
    {
      "name": "add-opencode-agent-backend-0b1f3631-agent-4",
      "status": "running",
      "branch": "git-native/add-opencode-agent-backend-0b1f3631-agent-4",
      "worktree_path": "/Users/rayen.faleh/swarm/.swarm/worktrees/add-opencode-agent-backend-0b1f3631-agent-4",
      "created_at": "2025-12-18T14:30:58.937384+00:00",
      "spec_content": "# Task\n\n# Task: Add OpenCode CLI agent backend\n\n## Description\nCreate OpenCodeCLIAgentBackend following GitNativeAgentBackend pattern for spawning opencode agents via subprocess\n\n## Scope\n- **Target files**: src/swarm_orchestrator/backends/opencode.py, tests/test_opencode_backend.py\n- **Estimated scope**: ~100 lines of code\n- **Focus areas**: OpenCodeCLIAgentBackend.__init__, OpenCodeCLIAgentBackend.spawn_agent, OpenCodeCLIAgentBackend.wait_for_completion, OpenCodeCLIAgentBackend.send_message, OpenCodeCLIAgentBackend.get_status\n\n## Implementation Goal\nCreate OpenCodeCLIAgentBackend class implementing AgentBackend interface - spawn agents using 'opencode run' with prompt written to .swarm-prompt.md file, track processes in _processes dict, use subprocess.Popen for async execution with -q flag for quiet mode\n\n## Verification Requirements\nUnit tests for spawn_agent writing prompt file and starting process, wait_for_completion with timeout handling, get_status returning correct finished state, send_message raising NotImplementedError (opencode CLI limitation)\n\n## Success Criteria\n- [ ] OpenCodeCLIAgentBackend implements all AgentBackend abstract methods\n- [ ] spawn_agent creates .swarm-prompt.md and starts opencode process\n- [ ] wait_for_completion handles timeout and returns AgentStatus correctly\n- [ ] Unit tests pass\n\n## Important Guidelines\n- Stay within the specified scope - avoid modifying unrelated files\n- Include tests as part of your implementation\n- Commit when all success criteria are met\n- Prefer minimal, focused changes over large refactors\n\n\n## Exploration Context\nOpenCode integration requires two new backends: OpenCodeCLIAgentBackend (spawning agents via 'opencode -p <prompt> -q') following the GitNativeAgentBackend pattern, and OpenCodeCLIBackend for LLM calls (using 'opencode -p <prompt> -f json') following ClaudeCLIBackend. Both use subprocess with non-interactive -p flag. Must update config.py BACKENDS registry and backends/__init__.py exports.\n\n## Relevant Files\n- **src/swarm_orchestrator/backends/base.py**: Abstract base classes defining AgentBackend and LLMBackend interfaces that opencode implementations must follow (patterns: ABC abstract interface, spawn_agent/wait_for_completion/send_message/get_status methods for AgentBackend, decompose/explore methods for LLMBackend)\n- **src/swarm_orchestrator/backends/git_native.py**: Reference implementation of AgentBackend using Claude CLI - spawns agents via subprocess with -p flag and --dangerously-skip-permissions (patterns: subprocess.Popen for async agent spawning, prompt written to .swarm-prompt.md file, _processes dict tracking running agents, communicate() for completion waiting)\n- **src/swarm_orchestrator/backends/llm.py**: LLM backend implementations - ClaudeCLIBackend uses 'claude -p prompt --output-format text' pattern for non-interactive CLI calls (patterns: subprocess.run for synchronous CLI calls, _call_cli abstraction, _parse_decompose_response for JSON extraction, timeout handling)\n- **src/swarm_orchestrator/config.py**: Configuration system with BACKENDS registry - defines valid backend choices and SwarmConfig dataclass (patterns: BACKENDS dict with 'agent' and 'llm' keys for registering new backends, get_backend_choices function, SwarmConfig.from_dict/to_dict for serialization)\n- **src/swarm_orchestrator/backends/__init__.py**: Backend exports - new implementations must be imported and added to __all__ (patterns: Explicit imports from implementation modules, __all__ list for public API)\n\n## Reference Documentation\n- [https://github.com/opencode-ai/opencode](https://github.com/opencode-ai/opencode): OpenCode is a Go-based AI coding assistant CLI. Supports -p flag for non-interactive mode: 'opencode -p \"prompt\"'. Also supports -f json for JSON output and -q/--quiet flag for scripts. Has --allowedTools and --excludedTools flags for tool control.\n- [https://opencode.ai/docs/cli/](https://opencode.ai/docs/cli/): OpenCode CLI docs show non-interactive mode auto-approves all permissions. Supports multiple AI providers (OpenAI, Anthropic, Gemini, Groq, etc). Can run 'opencode serve' for headless API server.\n- [https://github.com/opencode-ai/opencode/issues/277](https://github.com/opencode-ai/opencode/issues/277): Known limitation: cannot specify model when using -p flag in non-interactive mode. Issue open for model selection in CLI.\n\n---\n\n# CRITICAL: Swarm Agent Coordination\n\nYou are **Agent `add-opencode-agent-backend-0b1f3631-agent-4`** working on **Task `add-opencode-agent-backend-0b1f3631`** as part of a 5-agent swarm.\n\n> **CRITICAL**: You are one of multiple agents working on the same task concurrently. Follow these instructions EXACTLY to coordinate with other agents.\n\n---\n\n## The Stakes: Winner Takes All\n\nYou are competing against **5 highly capable AI agents** - all working on the exact same task. When everyone finishes:\n\n1. **Every agent reviews ALL implementations** (including yours)\n2. **Every agent votes** for the best solution\n3. **Majority wins** - that implementation gets merged\n4. **All others are DISCARDED** - their work is deleted\n\n### What This Means For You\n\n| If You Win | If You Lose |\n|------------|-------------|\n| Your code gets merged | Your code is **deleted** |\n| Your solution ships | Your work was for nothing |\n| You solved the problem | You wasted the effort |\n\n### How To Win\n\nThe agents judging your work are **smart and thorough**. They will evaluate:\n\n- **Does it actually work?** - Broken code loses immediately\n- **Is it complete?** - Partial solutions lose to complete ones\n- **Is it well-tested?** - Untested code is risky, tested code wins\n- **Is it clean?** - Readable, maintainable code beats clever hacks\n- **Does it handle edge cases?** - Robust solutions beat fragile ones\n\n### How To Lose\n\n**Over-engineering is a losing strategy.** The reviewers will penalize:\n\n- **Unnecessary abstractions** - Don't create helpers for one-time operations\n- **Excessive boilerplate** - More code = more bugs = more risk\n- **Features nobody asked for** - Solve the task, not imaginary future requirements\n- **Verbose comments on obvious code** - If the code needs that many comments, simplify it\n- **\"Just in case\" code** - Dead code paths, unused parameters, speculative features\n- **Gold-plating** - Perfect is the enemy of done\n\n> **The winning formula**: Solve the problem **exactly**. Not 80% of it. Not 150% of it. **100%** - complete, working, and nothing more.\n\n### What Reviewers Are Looking For\n\n```\n\u274c LOSES                              \u2705 WINS\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n500 lines with abstractions          50 lines that just work\n\"Flexible\" and \"extensible\"          Focused and purposeful\nHandles hypothetical edge cases      Handles real edge cases\nComments explaining the obvious      Self-documenting code\nFactory factories                    Direct implementation\n\"Production ready\" boilerplate       Clean, minimal solution\n```\n\n> **Bottom line**: The best code is code that doesn't exist. Every line you write is a liability. Write exactly what's needed - creative, elegant, minimal - and ship it. **The smartest solution wins, not the longest.**\n\n---\n\n## Your Identity\n\n| Field | Value |\n|-------|-------|\n| task_id | `add-opencode-agent-backend-0b1f3631` |\n| agent_id | `add-opencode-agent-backend-0b1f3631-agent-4` |\n| agent_count | 5 |\n\n**IMPORTANT**: Always use these EXACT IDs when calling MCP tools. Do not modify or guess IDs.\n\n---\n\n## Workflow Overview\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  PHASE 1        \u2502     \u2502  PHASE 2        \u2502     \u2502  PHASE 3        \u2502\n\u2502  Implement      \u2502 \u2500\u2500\u25b6 \u2502  Signal Done    \u2502 \u2500\u2500\u25b6 \u2502  Vote           \u2502\n\u2502  (work alone)   \u2502     \u2502  (coordinate)   \u2502     \u2502  (after ALL done)\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n---\n\n## Phase 1: Implementation\n\n> **CRITICAL**: You MUST commit your changes before proceeding to Phase 2. The merge will FAIL if you have uncommitted changes.\n\n### Development Approach: Test-Driven Development (TDD)\n\nWhen applicable, follow TDD:\n1. **Write tests FIRST** - Define expected behavior before implementation\n2. **Run tests** - Verify they fail (red)\n3. **Implement** - Write minimal code to pass tests\n4. **Run tests again** - Verify they pass (green)\n5. **Refactor** - Clean up while keeping tests green\n\n### Implementation Steps\n\n1. **Understand the task** - Read requirements carefully\n2. **Write tests first** (when applicable) - Define expected behavior\n3. **Implement your solution** - Write clean, working code\n4. **Run tests** - Ensure everything passes\n5. **COMMIT your changes** - This is MANDATORY\n\n### Git Commit Requirements\n\n> \u26a0\ufe0f **WARNING**: You MUST commit before calling `finished_work`. Uncommitted changes will cause merge failures.\n\n```bash\n# Stage your changes\ngit add -A\n\n# Commit with a clear, descriptive message\ngit commit -m \"feat: <brief description of what you implemented>\n\n- <bullet point of key change 1>\n- <bullet point of key change 2>\n- <bullet point of key change 3>\"\n```\n\n**Commit Message Guidelines**:\n- Use conventional commit format: `feat:`, `fix:`, `refactor:`, `test:`\n- First line: Brief summary (50 chars max)\n- Body: Bullet points explaining key changes\n- Be specific about WHAT changed and WHY\n\n### Quality Checklist (Your Competitors Will Check All of These)\n\nBefore committing, verify - **because the other agents WILL**:\n- [ ] All tests pass (run the test suite) - *broken tests = instant loss*\n- [ ] Code compiles/runs without errors - *crashes = instant loss*\n- [ ] Edge cases are handled - *fragile code loses to robust code*\n- [ ] Error handling is included - *unhandled errors = amateur work*\n- [ ] Code is readable and maintainable - *clever hacks lose to clean code*\n- [ ] Changes are committed (not just staged) - *uncommitted = disqualified*\n\n> **Ask yourself**: If a smart, critical reviewer looked at my code, would they find flaws? Fix them NOW, before voting.\n\n### Verify Your Commit\n\n```bash\n# Check that changes are committed (should show nothing to commit)\ngit status\n\n# Verify your commit exists\ngit log -1 --oneline\n```\n\n**DO NOT** proceed to Phase 2 until:\n1. All tests pass\n2. Your changes are COMMITTED (not just staged)\n3. `git status` shows a clean working tree\n\n---\n\n## Phase 2: Signal Completion\n\n> **CRITICAL**: You MUST call `finished_work` after committing. Other agents are waiting.\n\n### Step 1: Get Your Diff\n```bash\ngit diff HEAD~1\n```\n\n### Step 2: Call the MCP Tool\n```\nfinished_work(\n    task_id=\"add-opencode-agent-backend-0b1f3631\",\n    agent_id=\"add-opencode-agent-backend-0b1f3631-agent-4\",\n    implementation=\"<paste your git diff here>\"\n)\n```\n\n### Understanding the Response\nThe tool returns:\n```json\n{\n    \"success\": true,\n    \"agents_remaining\": 2,\n    \"all_finished\": false\n}\n```\n\n- `agents_remaining`: How many agents haven't finished yet\n- `all_finished`: `true` when ALL agents are done\n\n### What To Do Next\n\n| `all_finished` | Action |\n|----------------|--------|\n| `false` | **WAIT** using `sleep 30`, then poll `get_all_implementations` |\n| `true` | **PROCEED** to Phase 3 immediately |\n\n---\n\n## Phase 2.5: Waiting for Other Agents\n\n> **IMPORTANT**: Other agents work CONCURRENTLY. You must wait for them.\n> **DO NOT** call `get_all_implementations` immediately after `finished_work` - use `sleep` first!\n\n### Polling Strategy\n\n**CRITICAL**: Always sleep BEFORE polling, not after. This gives other agents time to finish.\n\n```bash\n# Step 1: Sleep first (REQUIRED - do not skip!)\nsleep 30\n\n# Step 2: Then check if all agents are done\nget_all_implementations(task_id=\"add-opencode-agent-backend-0b1f3631\")\n\n# Step 3: If not all finished, sleep and retry\n# Repeat until success\n```\n\n### Example Workflow\n```bash\n# After calling finished_work, WAIT before polling:\nsleep 30\n\n# Then call the MCP tool:\nget_all_implementations(task_id=\"add-opencode-agent-backend-0b1f3631\")\n\n# If it fails (others not done), sleep again and retry:\nsleep 30\nget_all_implementations(task_id=\"add-opencode-agent-backend-0b1f3631\")\n```\n\n**If it returns an error** like `\"Not all agents have finished yet (2/3)\"`:\n- This is NORMAL - other agents are still working\n- Run `sleep 30` in your terminal\n- Try `get_all_implementations` again\n\n**If it returns success** with implementations:\n- All agents are done\n- Proceed to Phase 3\n\n---\n\n## Phase 3: Review and Vote\n\n> **CRITICAL**: Only proceed here when `get_all_implementations` succeeds.\n\n### Step 1: Quick Scan (Use the Summary!)\n\nThe `get_all_implementations` response provides **structured summaries** for quick comparison:\n\n```json\n{\n    \"success\": true,\n    \"implementations\": [\n        {\n            \"agent_id\": \"add-opencode-agent-backend-0b1f3631-agent-0\",\n            \"session_name\": \"add-opencode-agent-backend-0b1f3631-agent-0\",\n            \"summary\": {\n                \"files_changed\": [\"src/foo.py\", \"tests/test_foo.py\"],\n                \"stats\": {\n                    \"files_count\": 2,\n                    \"added\": 48,\n                    \"deleted\": 12,\n                    \"total\": 60\n                }\n            },\n            \"condensed_diff\": \"diff --git a/src/foo.py...\\n+new code\\n-old code\"\n        }\n    ]\n}\n```\n\n**Build a comparison table mentally:**\n\n| Agent | Files | +Added | -Deleted | Total Changes |\n|-------|-------|--------|----------|---------------|\n| agent-0 | 2 | +48 | -12 | 60 |\n| agent-1 | 5 | +120 | -45 | 165 |\n| agent-2 | 2 | +30 | -8 | 38 |\n\n**Quick red flags:**\n- \u274c Too many files changed = over-engineered\n- \u274c High total changes for simple task = bloated\n- \u2b50 Minimal changes that solve the problem = elegant\n\n### Step 2: Review Condensed Diffs\n\nThe `condensed_diff` field contains a **minimal diff** with:\n- No context lines (only changed lines)\n- Normalized whitespace\n- File headers preserved\n\nThis is much smaller than full git diff - focus on **what actually changed**.\n\n### Step 3: Evaluate Each Solution\n\n**Vote for the solution that best balances these criteria:**\n\n| Criteria | Question to Ask | Red Flags |\n|----------|-----------------|-----------|\n| **Correctness** | Does it actually solve the problem? | Fails tests, wrong output, crashes |\n| **Completeness** | Are ALL requirements met? | Missing features, partial implementation |\n| **Elegance** | Is it the *smartest* solution? | Over-engineered, too many abstractions |\n| **Minimalism** | Does it do exactly what's needed? | Unnecessary code, boilerplate, dead paths |\n| **Robustness** | Does it handle *real* edge cases? | Fragile, unhandled errors |\n\n> **Prefer**: A 50-line solution that works perfectly over a 500-line \"enterprise\" solution.\n> **Penalize**: Over-engineering, unnecessary abstractions, speculative features, verbose comments on obvious code.\n\n### Step 4: Cast Your Vote\n```\ncast_vote(\n    task_id=\"add-opencode-agent-backend-0b1f3631\",\n    agent_id=\"add-opencode-agent-backend-0b1f3631-agent-4\",\n    voted_for=\"<agent_id of the BEST implementation>\",\n    reason=\"<brief explanation - 1-2 sentences>\"\n)\n```\n\n**RULES**:\n- You CANNOT vote for yourself - the system will reject self-votes\n- You MUST vote for exactly ONE other agent\n- Your vote is FINAL - no changes allowed\n- Be OBJECTIVE - vote for the best implementation among your competitors\n\n---\n\n## MCP Tools Reference\n\n### `finished_work`\nSignal that you completed your implementation.\n```\nfinished_work(\n    task_id: string,      # Your task ID\n    agent_id: string,     # Your agent ID\n    implementation: string # Your git diff\n)\n```\n\n### `get_all_implementations`\nGet all agents' implementations (only works when all are done).\n```\nget_all_implementations(\n    task_id: string       # Your task ID\n)\n```\n\n### `cast_vote`\nVote for the best implementation.\n```\ncast_vote(\n    task_id: string,      # Your task ID\n    agent_id: string,     # Your agent ID\n    voted_for: string,    # Agent ID you're voting for\n    reason: string        # Why this is the best\n)\n```\n\n### `get_vote_results`\nCheck voting status (optional, for debugging).\n```\nget_vote_results(\n    task_id: string       # Your task ID\n)\n```\n\n---\n\n## Error Handling\n\n### \"Task not found\"\n- Check your `task_id` is exactly: `add-opencode-agent-backend-0b1f3631`\n- Do not modify or guess the ID\n\n### \"Agent not found\"\n- Check your `agent_id` is exactly: `add-opencode-agent-backend-0b1f3631-agent-4`\n- Do not modify or guess the ID\n\n### \"Not all agents have finished\"\n- This is NORMAL during the waiting period\n- Wait 10-15 seconds and retry\n\n### \"Already voted\"\n- You can only vote once\n- Your vote has been recorded\n\n---\n\n## Timeline Example\n\n```\nTime    Agent-0          Agent-1          Agent-2\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n0:00    Start impl       Start impl       Start impl\n0:45    Still working    Finish impl      Still working\n0:46                     finished_work (2 remaining)\n0:47                     sleep 30...\n1:00    Finish impl                       Still working\n1:01    finished_work (1 remaining)\n1:17                     get_all (fail)\n1:17                     sleep 30...\n1:31                                      Finish impl\n1:32    sleep 30...                       finished_work (0!)\n1:47                     get_all \u2713\n1:48    (wakes up)                        sleep 30...\n2:02    get_all \u2713\n2:18                                      get_all \u2713\n2:20    Review & vote    Review & vote    Review & vote\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        CONSENSUS REACHED - Winner determined\n```\n\n---\n\n## Summary Checklist\n\n- [ ] **Phase 1**: Implement and commit your solution\n- [ ] **Phase 2**: Call `finished_work` with your diff\n- [ ] **Phase 2.5**: Run `sleep 30`, then poll `get_all_implementations` (repeat until success)\n- [ ] **Phase 3**: Review all solutions and call `cast_vote`\n\n---\n\n## Final Reminder: This Is A Competition\n\n> **5 agents. 5 implementations. Only 1 winner.**\n>\n> The other agents are skilled, thorough, and motivated. They will scrutinize your code for any weakness. A single failing test, an unhandled edge case, or sloppy code could cost you the win.\n>\n> **Don't just finish. Win.**\n\n---\n\n**START NOW**: Begin with Phase 1 - implement the task above.\n",
      "pid": null
    }
  ]
}